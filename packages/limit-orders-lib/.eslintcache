[{"/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/constants/index.ts":"1","/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/index.ts":"2","/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/limit-orders/index.ts":"3","/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/stoplimit-orders/core.ts":"4","/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/stoplimit-orders/index.ts":"5","/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/types/index.ts":"6","/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/utils/index.ts":"7","/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/utils/queries/constants.ts":"8","/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/utils/queries/index.ts":"9","/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/utils/queries/stoplimit.ts":"10"},{"size":6356,"mtime":1637937637934,"results":"11","hashOfConfig":"12"},{"size":241,"mtime":1637937638556,"results":"13","hashOfConfig":"12"},{"size":22071,"mtime":1637767527556,"results":"14","hashOfConfig":"12"},{"size":11948,"mtime":1637937638794,"results":"15","hashOfConfig":"12"},{"size":9780,"mtime":1637937638846,"results":"16","hashOfConfig":"12"},{"size":1764,"mtime":1637849940901,"results":"17","hashOfConfig":"12"},{"size":487,"mtime":1637767527556,"results":"18","hashOfConfig":"12"},{"size":4284,"mtime":1637937638900,"results":"19","hashOfConfig":"12"},{"size":5607,"mtime":1637767527556,"results":"20","hashOfConfig":"12"},{"size":4627,"mtime":1637937638952,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"2f6yvy",{"filePath":"24","messages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"28","messages":"29","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30"},{"filePath":"31","messages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"35","messages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"41","messages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/constants/index.ts",[],"/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/index.ts",[],"/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/limit-orders/index.ts",[],"/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/stoplimit-orders/core.ts",["43"],"import {\n  BigNumber,\n  constants,\n  utils,\n  ContractTransaction,\n  BigNumberish,\n  Contract,\n  Overrides,\n} from \"ethers\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport {\n  CHAIN_ID,\n  ETH_ADDRESS,\n  NATIVE_WRAPPED_TOKEN_ADDRESS,\n  GELATO_LIMIT_ORDERS_ADDRESS,\n  GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER,\n  NETWORK_HANDLERS,\n  SLIPPAGE_BPS,\n  SUBGRAPH_URL,\n  TWO_BPS_GELATO_FEE,\n} from \"../constants\";\nimport {\n  ERC20OrderRouter,\n  ERC20OrderRouter__factory,\n  ERC20__factory,\n  GelatoLimitOrders as GelatoBaseContract,\n  GelatoLimitOrders__factory as GelatoBase__factory,\n} from \"../contracts/types\";\nimport { queryPastOrders } from \"../utils/queries/stoplimit\";\nimport { Handler, ChainId, StopLimitOrder, TransactionData } from \"../types\";\nimport { isEthereumChain } from \"../utils\";\n\nexport const isValidChainIdAndHandler = (\n  chainId: ChainId,\n  handler: Handler\n): boolean => {\n  return NETWORK_HANDLERS[chainId].includes(handler);\n};\n\nexport const isFlashbotsCompatibleChainId = (chainId: ChainId): boolean => {\n  return chainId == CHAIN_ID.MAINNET || chainId == CHAIN_ID.GOERLI;\n};\n\nexport const isETHOrWETH = (\n  tokenAddress: string,\n  chainID: ChainId\n): boolean => {\n  const WETH_ADDRESS = NATIVE_WRAPPED_TOKEN_ADDRESS[chainID];\n  return (\n    tokenAddress.toLowerCase() === ETH_ADDRESS.toLowerCase() ||\n    tokenAddress.toLowerCase() === WETH_ADDRESS.toLowerCase()\n  );\n};\n\nexport class GelatoBase {\n  public _chainId: ChainId;\n  public _provider: Provider | undefined;\n  public _signer: Signer | undefined;\n  public _gelatoCore: GelatoBaseContract;\n  public _erc20OrderRouter: ERC20OrderRouter;\n  public _moduleAddress: string;\n  public _subgraphUrl: string;\n  public _abiEncoder: utils.AbiCoder;\n  public _handlerAddress?: string;\n  public _handler?: Handler;\n\n  public static slippageBPS = SLIPPAGE_BPS;\n  public static gelatoFeeBPS = TWO_BPS_GELATO_FEE;\n\n  get chainId(): ChainId {\n    return this._chainId;\n  }\n\n  get signer(): Signer | undefined {\n    return this._signer;\n  }\n\n  get provider(): Provider | undefined {\n    return this._provider;\n  }\n\n  get subgraphUrl(): string {\n    return this._subgraphUrl;\n  }\n\n  get handler(): Handler | undefined {\n    return this._handler;\n  }\n\n  get handlerAddress(): string | undefined {\n    return this._handlerAddress;\n  }\n\n  get moduleAddress(): string {\n    return this._moduleAddress;\n  }\n\n  get contract(): GelatoBaseContract {\n    return this._gelatoCore;\n  }\n\n  get erc20OrderRouter(): ERC20OrderRouter {\n    return this._erc20OrderRouter;\n  }\n\n  get abiEncoder(): any {\n    return this._abiEncoder;\n  }\n\n  constructor(\n    chainId: ChainId,\n    moduleAddress: string,\n    signerOrProvider?: Signer | Provider,\n    handler?: Handler,\n    handlerAddress?: string\n  ) {\n    if (handler && !isValidChainIdAndHandler(chainId, handler)) {\n      throw new Error(\"Invalid chainId and handler\");\n    }\n\n    this._chainId = chainId;\n    this._subgraphUrl = SUBGRAPH_URL[chainId];\n    this._signer = Signer.isSigner(signerOrProvider)\n      ? signerOrProvider\n      : undefined;\n    this._provider = Provider.isProvider(signerOrProvider)\n      ? signerOrProvider\n      : Signer.isSigner(signerOrProvider)\n      ? signerOrProvider.provider\n      : undefined;\n\n    this._gelatoCore = this._signer\n      ? GelatoBase__factory.connect(\n          GELATO_LIMIT_ORDERS_ADDRESS[this._chainId],\n          this._signer\n        )\n      : this._provider\n      ? GelatoBase__factory.connect(\n          GELATO_LIMIT_ORDERS_ADDRESS[this._chainId],\n          this._provider\n        )\n      : (new Contract(\n          GELATO_LIMIT_ORDERS_ADDRESS[this._chainId],\n          GelatoBase__factory.createInterface()\n        ) as GelatoBaseContract);\n\n    this._abiEncoder = new utils.AbiCoder();\n\n    this._erc20OrderRouter = this._signer\n      ? ERC20OrderRouter__factory.connect(\n          GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId],\n          this._signer\n        )\n      : this._provider\n      ? ERC20OrderRouter__factory.connect(\n          GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId],\n          this._provider\n        )\n      : (new Contract(\n          GELATO_LIMIT_ORDERS_ERC20_ORDER_ROUTER[this._chainId],\n          ERC20OrderRouter__factory.createInterface()\n        ) as ERC20OrderRouter);\n    this._handler = handler;\n    this._handlerAddress = handlerAddress;\n    this._moduleAddress = moduleAddress;\n  }\n\n  public async encodeLimitOrderCancellation(\n    order: StopLimitOrder,\n    checkIsActiveOrder?: boolean\n  ): Promise<TransactionData> {\n    if (!this._gelatoCore) throw new Error(\"No gelato limit orders contract\");\n\n    if (!order.inputToken) throw new Error(\"No input token in order\");\n    if (!order.witness) throw new Error(\"No witness in order\");\n    if (!order.outputToken) throw new Error(\"No output token in order\");\n    if (!order.minReturn) throw new Error(\"No minReturn in order\");\n    if (!order.owner) throw new Error(\"No owner\");\n\n    if (checkIsActiveOrder) {\n      const isActiveOrder = await this.isActiveOrder(order);\n      if (!isActiveOrder)\n        throw new Error(\"Order not found. Please review your order data.\");\n    }\n\n    const data = this._gelatoCore.interface.encodeFunctionData(\"cancelOrder\", [\n      this._moduleAddress,\n      order.inputToken,\n      order.owner,\n      order.witness,\n      order.data,\n    ]);\n\n    return {\n      data,\n      to: this._gelatoCore.address,\n      value: constants.Zero,\n    };\n  }\n\n  public async cancelLimitOrder(\n    order: StopLimitOrder,\n    checkIsActiveOrder?: boolean,\n    overrides?: Overrides\n  ): Promise<ContractTransaction> {\n    if (!this._signer) throw new Error(\"No signer\");\n    if (!this._gelatoCore) throw new Error(\"No gelato limit orders contract\");\n\n    if (!order.inputToken) throw new Error(\"No input token in order\");\n    if (!order.witness) throw new Error(\"No witness in order\");\n    if (!order.outputToken) throw new Error(\"No output token in order\");\n    if (!order.minReturn) throw new Error(\"No minReturn in order\");\n    if (!order.data) throw new Error(\"No data in order\");\n\n    if (checkIsActiveOrder) {\n      const isActiveOrder = await this.isActiveOrder(order);\n      if (!isActiveOrder)\n        throw new Error(\"Order not found. Please review your order data.\");\n    }\n\n    const owner = await this._signer.getAddress();\n\n    if (owner.toLowerCase() !== order.owner.toLowerCase())\n      throw new Error(\"Owner and signer mismatch\");\n\n    return this._gelatoCore.cancelOrder(\n      this._moduleAddress,\n      order.inputToken,\n      order.owner,\n      order.witness,\n      order.data,\n      overrides ?? {\n        gasLimit: isEthereumChain(this._chainId) ? 500000 : 1500000,\n      }\n    );\n  }\n\n  public async approveTokenAmount(\n    inputToken: string,\n    amount: BigNumberish,\n    overrides?: Overrides\n  ): Promise<ContractTransaction> {\n    if (!this._signer) throw new Error(\"No signer\");\n\n    return overrides\n      ? ERC20__factory.connect(inputToken, this._signer).approve(\n          this._erc20OrderRouter.address,\n          amount,\n          overrides\n        )\n      : ERC20__factory.connect(inputToken, this._signer).approve(\n          this._erc20OrderRouter.address,\n          amount\n        );\n  }\n\n  public async isActiveOrder(order: StopLimitOrder): Promise<boolean> {\n    if (!this._provider) throw new Error(\"No provider\");\n    if (!this._gelatoCore) throw new Error(\"No gelato limit orders contract\");\n\n    if (!order.module) throw new Error(\"No module in order\");\n    if (!order.inputToken) throw new Error(\"No input token in order\");\n    if (!order.owner) throw new Error(\"No owner in order\");\n    if (!order.witness) throw new Error(\"No witness in order\");\n    if (!order.data) throw new Error(\"No data in order\");\n\n    return this._gelatoCore.existOrder(\n      order.module,\n      order.inputToken,\n      order.owner,\n      order.witness,\n      order.data\n    );\n  }\n\n  public getExchangeRate(\n    inputValue: BigNumberish,\n    inputDecimals: number,\n    outputValue: BigNumberish,\n    outputDecimals: number,\n    invert = false\n  ): string {\n    const factor = BigNumber.from(10).pow(BigNumber.from(18));\n\n    if (invert) {\n      return BigNumber.from(inputValue)\n        .mul(factor)\n        .div(outputValue)\n        .mul(BigNumber.from(10).pow(BigNumber.from(outputDecimals)))\n        .div(BigNumber.from(10).pow(BigNumber.from(inputDecimals)))\n        .toString();\n    } else {\n      return BigNumber.from(outputValue)\n        .mul(factor)\n        .div(inputValue)\n        .mul(BigNumber.from(10).pow(BigNumber.from(inputDecimals)))\n        .div(BigNumber.from(10).pow(BigNumber.from(outputDecimals)))\n        .toString();\n    }\n  }\n\n  public getFeeAndSlippageAdjustedMinReturn(\n    outputAmount: BigNumberish,\n    extraSlippageBPS?: number\n  ): {\n    minReturn: string;\n    slippage: string;\n    gelatoFee: string;\n  } {\n    if (isEthereumChain(this._chainId))\n      throw new Error(\"Method not available for current chain.\");\n\n    if (extraSlippageBPS) {\n      if (!Number.isInteger(extraSlippageBPS))\n        throw new Error(\"Extra Slippage BPS must an unsigned integer\");\n    }\n\n    const gelatoFee = BigNumber.from(outputAmount)\n      .mul(GelatoBase.gelatoFeeBPS)\n      .div(10000)\n      .gte(1)\n      ? BigNumber.from(outputAmount).mul(GelatoBase.gelatoFeeBPS).div(10000)\n      : BigNumber.from(1);\n\n    const slippageBPS = extraSlippageBPS\n      ? extraSlippageBPS\n      : GelatoBase.slippageBPS;\n\n    const slippage = BigNumber.from(outputAmount).mul(slippageBPS).div(10000);\n\n    const minReturn = BigNumber.from(outputAmount).sub(gelatoFee).sub(slippage);\n\n    return {\n      minReturn: minReturn.toString(),\n      slippage: slippage.toString(),\n      gelatoFee: gelatoFee.toString(),\n    };\n  }\n\n  public getAdjustedMinReturn(\n    minReturn: BigNumberish,\n    extraSlippageBPS?: number\n  ): string {\n    if (isEthereumChain(this._chainId))\n      throw new Error(\"Method not available for current chain.\");\n\n    const gelatoFee = BigNumber.from(GelatoBase.gelatoFeeBPS);\n\n    const slippage = extraSlippageBPS\n      ? BigNumber.from(extraSlippageBPS)\n      : BigNumber.from(GelatoBase.slippageBPS);\n\n    const fees = gelatoFee.add(slippage);\n\n    const adjustedMinReturn = BigNumber.from(minReturn)\n      .mul(10000)\n      .div(BigNumber.from(10000).sub(fees));\n\n    return adjustedMinReturn.toString();\n  }\n\n  public getExecutionPrice(\n    inputAmount: BigNumberish,\n    inputDecimals: number,\n    outputAmount: BigNumberish,\n    outputDecimals: number,\n    isInverted = false\n  ): string {\n    const factor = BigNumber.from(10).pow(\n      BigNumber.from(isInverted ? outputDecimals : inputDecimals)\n    );\n\n    if (isInverted) {\n      return BigNumber.from(inputAmount)\n        .mul(factor)\n        .div(outputAmount)\n        .toString();\n    } else {\n      return BigNumber.from(outputAmount)\n        .mul(factor)\n        .div(inputAmount)\n        .toString();\n    }\n  }\n\n  public async getPastOrders(\n    owner: string,\n    includeOrdersWithNullHandler = false\n  ): Promise<StopLimitOrder[]> {\n    const isEthereumNetwork = isEthereumChain(this._chainId);\n    const orders = await queryPastOrders(owner, this._chainId);\n    return orders\n      .map((order) => ({\n        ...order,\n        adjustedMinReturn: isEthereumNetwork\n          ? order.minReturn\n          : this.getAdjustedMinReturn(order.minReturn),\n      }))\n      .filter((order) => {\n        if (this._handler && !order.handler) {\n          return includeOrdersWithNullHandler ? true : false;\n        } else {\n          return this._handler ? order.handler === this._handlerAddress : true;\n        }\n      });\n  }\n\n  public _getKey(order: StopLimitOrder): string {\n    return utils.keccak256(\n      this._abiEncoder.encode(\n        [\"address\", \"address\", \"address\", \"address\", \"bytes\"],\n        [order.module, order.inputToken, order.owner, order.witness, order.data]\n      )\n    );\n  }\n}\n","/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/stoplimit-orders/index.ts",[],"/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/types/index.ts",[],"/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/utils/index.ts",[],"/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/utils/queries/constants.ts",[],"/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/utils/queries/index.ts",[],"/Users/harrytrippel/Desktop/gelato/swap-orders-lib/packages/limit-orders-lib/src/utils/queries/stoplimit.ts",[],{"ruleId":"44","severity":1,"message":"45","line":107,"column":21,"nodeType":"46","messageId":"47","endLine":107,"endColumn":24,"suggestions":"48"},"@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["49","50"],{"messageId":"51","fix":"52","desc":"53"},{"messageId":"54","fix":"55","desc":"56"},"suggestUnknown",{"range":"57","text":"58"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"57","text":"59"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",[2615,2618],"unknown","never"]